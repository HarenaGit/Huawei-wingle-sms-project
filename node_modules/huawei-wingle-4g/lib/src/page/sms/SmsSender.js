"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const log4js_1 = __importDefault(require("log4js"));
const StringUtils_1 = require("../../utils/StringUtils");
const Connection_1 = __importDefault(require("../../connection/Connection"));
const SLEEP_DURATION = 5000;
const MAX_TRY_VERIFYING_SMS_SENT = 100;
class default_1 {
    constructor(login) {
        this.login = login;
        this.connection = login.getConnnection();
        this.logger = log4js_1.default.getLogger(StringUtils_1.substringAfter(__filename, 'huawei-wingle-4g'));
    }
    activeLog(activeLog) {
        this.login.activeLog(activeLog);
        this.logger.level = activeLog ? 'debug' : 'OFF';
    }
    sendSms(phoneNumbers, content) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameters = this.buildParameters(phoneNumbers, content);
            yield this.connection.openHomePage();
            yield this.login.login();
            const response = yield this.connection.post('/api/sms/send-sms', parameters);
            if (!Connection_1.default.isSuccess(response)) {
                throw new Error('Unable to send SMS');
            }
            return this.verifySmsSent();
        });
    }
    buildParameters(phoneNumbers, content) {
        let numbers = [];
        if (Array.isArray(phoneNumbers)) {
            phoneNumbers.forEach(phoneNumber => numbers.push(phoneNumber));
        }
        else {
            numbers.push(phoneNumbers);
        }
        numbers = numbers.filter(phone => phone);
        if (!numbers.length) {
            throw new Error('No phone number provided');
        }
        if (!content) {
            throw new Error('No content SMS provided');
        }
        if (content.length > 160) {
            throw new Error('Content SMS length cannot be upper than 160');
        }
        const phones = numbers.map(phoneNumber => `<Phone>${phoneNumber}</Phone>`).join('');
        const date = this.getDate();
        return `<?xml version: "1.0" encoding="UTF-8"?><request><Index>-1</Index><Phones>${phones}</Phones><Sca></Sca><Content>${content}</Content><Length>${content.length}</Length><Reserved>1</Reserved><Date>${date}</Date></request>`;
    }
    getDate() {
        const date = new Date();
        const year = date.getFullYear();
        const month = StringUtils_1.toTwo(date.getMonth() + 1);
        const day = StringUtils_1.toTwo(date.getDate());
        const hours = StringUtils_1.toTwo(date.getHours());
        const minutes = StringUtils_1.toTwo(date.getMinutes());
        const secondes = StringUtils_1.toTwo(date.getSeconds());
        return `${year}-${month}-${day} ${hours}:${minutes}:${secondes}`;
    }
    verifySmsSent() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = new Map();
            for (let i = 0; i < MAX_TRY_VERIFYING_SMS_SENT; i++) {
                this.logger.debug(`Attempt to verify SMS sent with retry : ${i}`);
                const statusDocument = yield this.getStatusDocument();
                if (this.allDone(statusDocument)) {
                    const successPhoneNumbers = this.getPhoneNumbersInDocument(statusDocument, true);
                    successPhoneNumbers.forEach(successPhoneNumber => results.set(successPhoneNumber, true));
                    this.logger.debug(`Success phone numbers count : ${successPhoneNumbers.length}`);
                    const failedPhoneNumbers = this.getPhoneNumbersInDocument(statusDocument, false);
                    failedPhoneNumbers.forEach(failedPhoneNumber => results.set(failedPhoneNumber, false));
                    this.logger.debug(`Failed phone numbers count : ${failedPhoneNumbers.length}`);
                    return results;
                }
                yield this.sleep();
            }
            throw new Error(`Attempting to verify SMS sent reached max authorised : ${MAX_TRY_VERIFYING_SMS_SENT}`);
        });
    }
    sleep() {
        return new Promise(resolve => setTimeout(() => resolve(), SLEEP_DURATION));
    }
    getStatusDocument() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.connection.get('/api/sms/send-status');
            return response.document;
        });
    }
    allDone(statusDocument) {
        const phoneElement = statusDocument.querySelector('Phone');
        if (!phoneElement) {
            throw new Error('Unable to determinate if all done or not');
        }
        return phoneElement.textContent === '';
    }
    getPhoneNumbersInDocument(statusDocument, isSuccessContext) {
        var _a;
        const selector = isSuccessContext ? 'SucPhone' : 'FailPhone';
        const phoneNumbers = (_a = statusDocument.querySelector(selector)) === null || _a === void 0 ? void 0 : _a.textContent;
        return phoneNumbers ? phoneNumbers.split(',') : [];
    }
}
exports.default = default_1;
//# sourceMappingURL=SmsSender.js.map